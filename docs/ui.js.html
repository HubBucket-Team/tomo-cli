<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ui.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ui.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file UI Components
 * @author Jason Wohlgemuth
 * @module ui
 * @requires module:utils
 * @requires module:commands
 */
import React, {useContext, useEffect, useReducer, Component} from 'react';
import PropTypes from 'prop-types';
import {isFunction, isString, isUndefined} from 'lodash';
import Queue from 'p-queue';
import {Box, Color, Text, StdinContext} from 'ink';
import {default as InkBox} from 'ink-box';
import Spinner from 'ink-spinner';
import SelectInput from 'ink-select-input';
import figures from 'figures';
import commands from './commands';
import {getIntendedInput} from './utils';

const Check = ({isSkipped}) => (&lt;Text bold>
    &lt;Color green={!isSkipped} dim={isSkipped}>{figures.tick}&lt;/Color>
&lt;/Text>);
const Item = ({isSelected, label}) => &lt;Color bold={isSelected} cyan={isSelected}>{label}&lt;/Color>;
const Indicator = ({isSelected}) => &lt;Box marginRight={1}>{isSelected ? &lt;Color bold cyan>{figures.arrowRight}&lt;/Color> : ' '}&lt;/Box>;
const SubCommandSelect = ({items, onSelect}) => &lt;Box paddingTop={1} paddingBottom={1} paddingLeft={1}>
    &lt;SelectInput
        items={items}
        onSelect={onSelect}
        itemComponent={Item}
        indicatorComponent={Indicator}
    >&lt;/SelectInput>
&lt;/Box>;
/**
 * @private
 * @function UnderConstruction
 * @constructor
 * @description Component to display "under construction" warning for capabilities not yet implemented.
 */
const UnderConstruction = () => &lt;Box marginBottom={1}>
    &lt;InkBox padding={{left: 1, right: 1}} margin={{left: 1, top: 1}}>
        &lt;Color bold yellow>UNDER CONSTRUCTION&lt;/Color>
    &lt;/InkBox>
&lt;/Box>;
/**
 * @private
 * @function ErrorMessage
 * @constructor
 * @description Used by ErrorBoundary component to display error message and data
 * @property {Object} props
 * @property {string} props.info Error details
 * @return {string} HTML markup for ErrorMessage component
 */
const ErrorMessage = ({info}) => &lt;Box flexDirection={'column'} marginBottom={1}>
    &lt;InkBox borderColor={'yellow'} margin={{left: 1, top: 1}} padding={{left: 1, right: 1}}>
        &lt;Color yellow>(╯°□ °)╯ ┻━┻ arrrgh...&lt;/Color>
    &lt;/InkBox>
    &lt;Box marginLeft={4}>
        ↳ &lt;Color dim>Something went wrong...&lt;/Color>
    &lt;/Box>
    &lt;Box marginLeft={6} marginTop={1}>
        &lt;Color dim>&lt;Box>{info}&lt;/Box>&lt;/Color>
    &lt;/Box>
&lt;/Box>;
/**
 * @private
 * @function ErrorBoundary
 * @constructor
 * @extends React.Component
 * @description Error boundary used around UI component
 */
class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            info: '',
            error: {},
            hasError: false
        };
    }
    static getDerivedStateFromError() {
        return {hasError: true};
    }
    componentDidCatch(error, info) {
        this.setState({error, info});
    }
    render() {
        const {error, hasError} = this.state;
        const {children} = this.props;
        return hasError ? &lt;ErrorMessage error={error}/> : children;
    }
}
/**
 * @function Warning
 * @constructor
 * @description Component to display warning message requiring user input
 * @property {Object} props
 * @property {function} props.callback Function to be called after user interacts with warning
 */
export const Warning = ({callback, children}) => {
    const {setRawMode, stdin} = useContext(StdinContext);
    useEffect(() => {
        setRawMode &amp;&amp; setRawMode(true);
        stdin.on('data', callback);
        return function cleanup() {
            stdin.removeListener('data', callback);
            setRawMode &amp;&amp; setRawMode(false);
        };
    });
    return &lt;Box flexDirection={'column'} marginBottom={1}>
        &lt;InkBox borderColor={'yellow'} margin={{left: 1, top: 1}} padding={{left: 1, right: 1}}>
            &lt;Color yellow>oops...&lt;/Color>
        &lt;/InkBox>
        &lt;Box marginLeft={4}>
            ↳ {children}
        &lt;/Box>
        &lt;Box marginLeft={6} marginTop={1}>
            &lt;Color dim>Press &lt;/Color>&lt;Text bold>ENTER&lt;/Text>&lt;Color dim> to continue&lt;/Color>
        &lt;/Box>
    &lt;/Box>;
};
/**
 * @function Task
 * @constructor
 * @description Task component
 * @property {Object} props
 * @property {boolean} props.isComplete Control display of check (true) or loading (false)
 * @property {boolean} props.isSkipped Control color of check - green (false) or dim (true)
 * @property {string} props.text Task text
 * @example
 * &lt;Task text={'This task is done before it starts'} isComplete={true}>&lt;/Task>
 */
export const Task = ({isComplete, isSkipped, text}) => &lt;Box flexDirection='row' marginLeft={3}>
    {isComplete ?
        &lt;Check isSkipped={isSkipped}>&lt;/Check> :
        &lt;Color cyan>&lt;Spinner>&lt;/Spinner>&lt;/Color>
    } &lt;Text>&lt;Color dim={isComplete}>{text}&lt;/Color>&lt;/Text>
&lt;/Box>;
/**
 * @function TaskList
 * @constructor
 * @description Task list component
 * @property {Object} props
 * @property {string} props.command Command - new | create | add
 * @property {Object} props.options Command line flags (see help)
 * @property {string[]} props.terms Terms - eslint | babel | jest | postcss | docs
 * @example
 * &lt;TaskList command={'add'} terms={'eslint'} options={{skipInstall: true}}>&lt;/TaskList>
 */
export const TaskList = ({command, options, terms}) => {
    const reducer = (state, {type, payload}) => {
        const {completed, error, skipped} = state;
        if (type === 'complete') {
            return {
                completed: [...completed, payload],
                error,
                skipped
            };
        } else if (type === 'skipped') {
            return {
                completed,
                error,
                skipped: [...skipped, payload]
            };
        } else if (type === 'error') {
            return {
                completed,
                error: {
                    status: Symbol('Error'),
                    details: payload
                },
                skipped
            };
        }
    };
    const initialState = {
        completed: [],
        error: {
            status: Symbol('OK'),
            details: ''
        },
        skipped: []
    };
    const [state, dispatch] = useReducer(reducer, initialState);
    const queue = new Queue({concurrency: 1});
    const tasks = commands[command][terms[0]];
    useEffect(() => {
        async function populateQueue() {
            for (const [index, item] of tasks.entries()) {
                const {condition, task} = item;
                try {
                    if (await condition(options)) {
                        await queue
                            .add(() => task(options))
                            .then(() => dispatch({type: 'complete', payload: index}))
                            .catch(() => console.error('Error adding task to queue...')); // eslint-disable-line no-console
                    } else {
                        dispatch({type: 'skipped', payload: index});
                    }
                } catch (error) {
                    dispatch({type: 'error', payload: error});
                }
            }
        }
        populateQueue();
    }, []);
    return &lt;Box flexDirection={'column'} marginBottom={1}>
        &lt;InkBox
            margin={{left: 1, top: 1}}
            padding={{left: 1, right: 1}}
            borderColor={((state.completed.length + state.skipped.length) === tasks.length) ? 'green' : 'cyan'}
            borderStyle={'round'}>
            &lt;Color bold white>{command} {terms.join(' ')}&lt;/Color>
        &lt;/InkBox>
        &lt;Box flexDirection='column' marginBottom={1}>
            {tasks.map(({optional, text}, index) => {
                const {completed, skipped} = state;
                const isSkipped = skipped.includes(index);
                const isComplete = completed.includes(index) || isSkipped;
                const shouldBeShown = isUndefined(optional) || (isFunction(optional) &amp;&amp; optional(options));
                return shouldBeShown ?
                    &lt;Task text={text} isSkipped={isSkipped} isComplete={isComplete} key={index}>&lt;/Task> :
                    &lt;Box key={index}>&lt;/Box>;
            })}
        &lt;/Box>
    &lt;/Box>;
};
class UI extends Component {
    constructor(props) {
        super(props);
        const {input} = props;
        const [command, ...terms] = input;
        const hasCommand = isString(command);
        const hasTerms = terms.length > 0;
        const [intendedCommand, intendedTerms] = hasCommand ? getIntendedInput(commands, command, terms) : [, []];
        const compareTerms = (term, index) => (term !== terms[index]);
        const showWarning = (command !== intendedCommand) || (intendedTerms.map(compareTerms).some(Boolean));
        this.state = {
            hasTerms,
            hasCommand,
            showWarning,
            intendedTerms,
            intendedCommand
        };
        this.updateWarning = this.updateWarning.bind(this);
        this.updateTerms = this.updateTerms.bind(this);
    }
    render() {
        const {flags} = this.props;
        const {hasCommand, hasTerms, intendedCommand, intendedTerms, showWarning} = this.state;
        const {ignoreWarnings} = flags;
        const VALID_COMMANDS = hasCommand ? Object.keys(commands[intendedCommand]) : [];
        const selectInputCommandItems = hasCommand ? VALID_COMMANDS.map(command => ({label: command, value: command})) : [];
        return &lt;ErrorBoundary>
            {(showWarning &amp;&amp; !ignoreWarnings) ?
                &lt;Warning callback={this.updateWarning}>
                    &lt;Text>Did you mean &lt;Color bold green>{intendedCommand} {intendedTerms.join(' ')}&lt;/Color>?&lt;/Text>
                &lt;/Warning> :
                (hasCommand &amp;&amp; hasTerms) ?
                    &lt;TaskList command={intendedCommand} terms={intendedTerms} options={flags}>&lt;/TaskList> :
                    hasCommand ?
                        &lt;SubCommandSelect items={selectInputCommandItems} onSelect={this.updateTerms}>&lt;/SubCommandSelect> :
                        &lt;UnderConstruction/>
            }
        &lt;/ErrorBoundary>;
    }
    updateWarning(data) {
        const key = String(data);
        (key === '\r') ? this.setState({showWarning: false}) : process.exit(0);
    }
    updateTerms({value}) {
        this.setState({
            hasTerms: true,
            intendedTerms: [value]
        });
    }
}
Check.propTypes = {
    isSkipped: PropTypes.bool
};
Check.defaultProps = {
    isSkipped: false
};
SubCommandSelect.propTypes = {
    items: PropTypes.arrayOf(PropTypes.object),
    onSelect: PropTypes.func
};
Indicator.propTypes = {
    isSelected: PropTypes.bool
};
Indicator.defaultProps = {
    isSelected: false
};
Item.propTypes = {
    isSelected: PropTypes.bool,
    label: PropTypes.string.isRequired
};
Item.defaultProps = {
    isSelected: false
};
ErrorMessage.propTypes = {
    info: PropTypes.string
};
ErrorBoundary.propTypes = {
    children: PropTypes.node
};
Task.propTypes = {
    isComplete: PropTypes.bool,
    isSkipped: PropTypes.bool,
    text: PropTypes.string
};
Task.defaultProps = {
    isComplete: false,
    isSkipped: false,
    text: 'task description'
};
TaskList.propTypes = {
    command: PropTypes.string,
    options: PropTypes.any,
    terms: PropTypes.arrayOf(PropTypes.string)
};
TaskList.defaultProps = {
    command: '',
    options: {skipInstall: false},
    terms: []
};
Warning.propTypes = {
    callback: PropTypes.func,
    children: PropTypes.node
};
UI.propTypes = {
    input: PropTypes.array,
    flags: PropTypes.object
};
UI.defaultProps = {
    input: [],
    flags: {}
};

export default UI;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-app.html">app</a></li><li><a href="module-commands.html">commands</a></li><li><a href="module-plugins_logging.html">plugins/logging</a></li><li><a href="module-ui.html">ui</a></li><li><a href="module-utils.html">utils</a></li><li><a href="plugins_redux.module_state.html">plugins/redux.state</a></li></ul><h3>Classes</h3><ul><li><a href="module-ui-Task.html">Task</a></li><li><a href="module-ui-TaskList.html">TaskList</a></li><li><a href="module-ui-Warning.html">Warning</a></li><li><a href="module-utils-BabelConfigModuleEditor.html">BabelConfigModuleEditor</a></li><li><a href="module-utils-EslintConfigModuleEditor.html">EslintConfigModuleEditor</a></li><li><a href="module-utils-PackageJsonEditor.html">PackageJsonEditor</a></li><li><a href="module-utils-PostcssConfigEditor.html">PostcssConfigEditor</a></li><li><a href="module-utils-Scaffolder.html">Scaffolder</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Marionette">Marionette</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Apr 17 2019 18:58:24 GMT+0300 (East Africa Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
